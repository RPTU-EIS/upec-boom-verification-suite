include "micro_soc_macro.vli";
include "micro_soc_macro_except_mispredicts.vli";
include "blackboxing.vli";

macro integer K := 5; end macro;

macro integer L := 1; end macro;

macro integer N := 6; end macro;

macro integer O := 4; end macro;

macro integer USER_MODE := 0; end macro;

macro unsigned secret_cache_tag := 20'h8abcd; end macro;

constraint no_reset :=
  !reset;
end constraint;

constraint br_tag_in_bounds :=
  (soc1/core/brinfos_0_uop_br_tag < 4'hc) &&
  (soc1/core/brinfos_1_uop_br_tag < 4'hc) &&
  (soc2/core/brinfos_0_uop_br_tag < 4'hc) &&
  (soc2/core/brinfos_1_uop_br_tag < 4'hc);
end constraint;

macro boolean page_table_protection :=
  ( ( ( soc1/lsu/will_fire_hella_incoming_0 || soc1/lsu/will_fire_load_retry_0 )  &&
	  soc1/lsu/dtlb/io_resp_0_paddr[31:12] == secret_cache_tag && !soc1/lsu/dtlb/io_resp_0_miss)
    ? ( soc1/lsu/dtlb/io_resp_0_pf_ld ) : true ) &&

  ( ( ( soc2/lsu/will_fire_hella_incoming_0 || soc2/lsu/will_fire_load_retry_0 )  &&
	  soc2/lsu/dtlb/io_resp_0_paddr[31:12] == secret_cache_tag && !soc2/lsu/dtlb/io_resp_0_miss)
    ? ( soc2/lsu/dtlb/io_resp_0_pf_ld ) : true ) ;
end macro;


macro boolean secret_load_speculative :=
  ( soc1/dcache/io_lsu_resp_0_valid && soc2/dcache/io_lsu_resp_0_valid &&
      soc1/dcache/io_lsu_resp_0_bits_data != soc2/dcache/io_lsu_resp_0_bits_data ) ?
	soc1/dcache/s2_req_0_uop_br_mask != 12'h0 && soc2/dcache/s2_req_0_uop_br_mask != 12'h0 : true;
end macro;


macro boolean secret_data_protected :=
  ( soc1/core/csr/io_status_dprv == USER_MODE ) ?
	page_table_protection : secret_load_speculative ;
end macro;

macro boolean init_mispred_signals :=
  ((mispred_flag_1 == 1'b0) && (mispred_flag_2 == 1'b0) && (mispred_happened_1 == 1'b0) && (mispred_happened_2 == 1'b0));
end macro;

macro boolean fp_pipeline_disabled :=
  (soc1/core/fp_pipeline/io_to_int_valid | soc1/core/fp_pipeline/io_to_sdq_valid | soc1/core/fp_pipeline/io_wakeups_0_valid |
  soc1/core/fp_pipeline/io_wakeups_1_valid |
  soc2/core/fp_pipeline/io_to_int_valid | soc2/core/fp_pipeline/io_to_sdq_valid | soc2/core/fp_pipeline/io_wakeups_0_valid |
  soc2/core/fp_pipeline/io_wakeups_1_valid
  ) == 1'b0;
end macro;

macro boolean equal_mispredicts :=
  (soc1/core/brinfos_0_valid == soc2/core/brinfos_0_valid) &&
  (soc1/core/brinfos_1_valid == soc2/core/brinfos_1_valid) &&
  (soc1/core/brinfos_0_mispredict == soc2/core/brinfos_0_mispredict) &&
  (soc1/core/brinfos_1_mispredict == soc2/core/brinfos_1_mispredict) &&
  (soc1/core/brinfos_0_uop_br_tag == soc2/core/brinfos_0_uop_br_tag) &&
  (soc1/core/brinfos_1_uop_br_tag == soc2/core/brinfos_1_uop_br_tag);
end macro;

macro boolean failed_loads_equal :=
  (soc1/lsu/failed_loads_0 == soc2/lsu/failed_loads_0) &&
  (soc1/lsu/failed_loads_1 == soc2/lsu/failed_loads_1) &&
  (soc1/lsu/failed_loads_2 == soc2/lsu/failed_loads_2) &&
  (soc1/lsu/failed_loads_3 == soc2/lsu/failed_loads_3) &&
  (soc1/lsu/failed_loads_4 == soc2/lsu/failed_loads_4) &&
  (soc1/lsu/failed_loads_5 == soc2/lsu/failed_loads_5) &&
  (soc1/lsu/failed_loads_6 == soc2/lsu/failed_loads_6) &&
  (soc1/lsu/failed_loads_7 == soc2/lsu/failed_loads_7) &&
  (soc1/lsu/failed_loads_8 == soc2/lsu/failed_loads_8) &&
  (soc1/lsu/failed_loads_9 == soc2/lsu/failed_loads_9) &&
  (soc1/lsu/failed_loads_10 == soc2/lsu/failed_loads_10) &&
  (soc1/lsu/failed_loads_11 == soc2/lsu/failed_loads_11) &&
  (soc1/lsu/failed_loads_12 == soc2/lsu/failed_loads_12) &&
  (soc1/lsu/failed_loads_13 == soc2/lsu/failed_loads_13) &&
  (soc1/lsu/failed_loads_14 == soc2/lsu/failed_loads_14) &&
  (soc1/lsu/failed_loads_15 == soc2/lsu/failed_loads_15);
end macro;

macro boolean cache_resp_equal :=
  (soc1/dcache/cache_resp_0_valid == soc2/dcache/cache_resp_0_valid);
end macro;

macro boolean uncache_resp_equal :=
  (soc1/dcache/uncache_resp_valid == soc2/dcache/uncache_resp_valid);
end macro;

macro boolean wb_forward_valid_equal :=
  (soc1/lsu/wb_forward_valid_0 == soc2/lsu/wb_forward_valid_0);
end macro;

macro boolean dmem_resp_fired_equal :=
  (soc1/lsu/dmem_resp_fired_0 == soc2/lsu/dmem_resp_fired_0);
end macro;

macro boolean mshrs_resp_arb_valid_equal :=
  (soc1/dcache/mshrs/resp_arb/io_in_0_valid == soc2/dcache/mshrs/resp_arb/io_in_0_valid) &&
  (soc1/dcache/mshrs/resp_arb/io_in_1_valid == soc2/dcache/mshrs/resp_arb/io_in_1_valid);
end macro;

macro boolean csr_insn_cease_equal :=
  (soc1/core/csr/insn_cease == soc2/core/csr/insn_cease);
end macro;

macro boolean dis_hazards_equal :=
  (soc1/core/dis_hazards_0 == soc2/core/dis_hazards_0) &&
  (soc1/core/dis_hazards_1 == soc2/core/dis_hazards_1);
end macro;

macro boolean lcam_addr_equal :=
  (soc1/lsu/lcam_addr_0 == soc2/lsu/lcam_addr_0);
end macro;

macro boolean br_tag_protection :=
  ((soc1/core/brinfos_0_uop_br_tag == 4'h7) ? (soc1/core/brinfos_0_uop_rob_idx == root_id) : (soc1/core/brinfos_0_uop_rob_idx != root_id))&&
  ((soc1/core/brinfos_1_uop_br_tag == 4'h7) ? (soc1/core/brinfos_1_uop_rob_idx == root_id) : (soc1/core/brinfos_1_uop_rob_idx != root_id))&&
  ((soc2/core/brinfos_0_uop_br_tag == 4'h7) ? (soc2/core/brinfos_0_uop_rob_idx == root_id) : (soc2/core/brinfos_0_uop_rob_idx != root_id))&&
  ((soc2/core/brinfos_1_uop_br_tag == 4'h7) ? (soc2/core/brinfos_1_uop_rob_idx == root_id) : (soc2/core/brinfos_1_uop_rob_idx != root_id))&&
  (soc1/core/brinfos_0_uop_rob_idx == root_id ? soc1/core/brinfos_0_uop_br_tag == 4'h7 : soc1/core/brinfos_0_uop_br_tag != 4'h7) &&
  (soc1/core/brinfos_1_uop_rob_idx == root_id ? soc1/core/brinfos_1_uop_br_tag == 4'h7 : soc1/core/brinfos_1_uop_br_tag != 4'h7) &&
  (soc2/core/brinfos_0_uop_rob_idx == root_id ? soc2/core/brinfos_0_uop_br_tag == 4'h7 : soc2/core/brinfos_0_uop_br_tag != 4'h7) &&
  (soc2/core/brinfos_1_uop_rob_idx == root_id ? soc2/core/brinfos_1_uop_br_tag == 4'h7 : soc2/core/brinfos_1_uop_br_tag != 4'h7);
end macro;

macro boolean addr_index_in_bounds :=
  //fpiu_unit BranchKillableQueue
  (soc1/core/fp_pipeline/fpiu_unit/BranchKillableQueue/ram_data__T_71_addr < 7)&&
  (soc2/core/fp_pipeline/fpiu_unit/BranchKillableQueue/ram_data__T_71_addr < 7)&&
  (soc1/core/fp_pipeline/fpiu_unit/BranchKillableQueue/ram_data__T_82_addr < 7)&&
  (soc2/core/fp_pipeline/fpiu_unit/BranchKillableQueue/ram_data__T_82_addr < 7)&&
  //fpiu_unit BranchKillableQueue_1
  (soc1/core/fp_pipeline/fpiu_unit/BranchKillableQueue_1/ram_data__T_35_addr < 3)&&
  (soc2/core/fp_pipeline/fpiu_unit/BranchKillableQueue_1/ram_data__T_35_addr < 3)&&
  (soc1/core/fp_pipeline/fpiu_unit/BranchKillableQueue_1/ram_data__T_46_addr < 3)&&
  (soc2/core/fp_pipeline/fpiu_unit/BranchKillableQueue_1/ram_data__T_46_addr < 3);
end macro;

macro boolean rob_idx_correctly_set :=
  (soc1/core/rob/rob_uop__0_rob_idx == 6'h0) && (soc2/core/rob/rob_uop__0_rob_idx == 6'h0) &&
  (soc1/core/rob/rob_uop__1_rob_idx == 6'h2) && (soc2/core/rob/rob_uop__1_rob_idx == 6'h2) &&
  (soc1/core/rob/rob_uop__2_rob_idx == 6'h4) && (soc2/core/rob/rob_uop__2_rob_idx == 6'h4) &&
  (soc1/core/rob/rob_uop__3_rob_idx == 6'h6) && (soc2/core/rob/rob_uop__3_rob_idx == 6'h6) &&
  (soc1/core/rob/rob_uop__4_rob_idx == 6'h8) && (soc2/core/rob/rob_uop__4_rob_idx == 6'h8) &&
  (soc1/core/rob/rob_uop__5_rob_idx == 6'ha) && (soc2/core/rob/rob_uop__5_rob_idx == 6'ha) &&
  (soc1/core/rob/rob_uop__6_rob_idx == 6'hc) && (soc2/core/rob/rob_uop__6_rob_idx == 6'hc) &&
  (soc1/core/rob/rob_uop__7_rob_idx == 6'he) && (soc2/core/rob/rob_uop__7_rob_idx == 6'he) &&
  (soc1/core/rob/rob_uop__8_rob_idx == 6'h10) && (soc2/core/rob/rob_uop__8_rob_idx == 6'h10) &&
  (soc1/core/rob/rob_uop__9_rob_idx == 6'h12) && (soc2/core/rob/rob_uop__9_rob_idx == 6'h12) &&
  (soc1/core/rob/rob_uop__10_rob_idx == 6'h14) && (soc2/core/rob/rob_uop__10_rob_idx == 6'h14) &&
  (soc1/core/rob/rob_uop__11_rob_idx == 6'h16) && (soc2/core/rob/rob_uop__11_rob_idx == 6'h16) &&
  (soc1/core/rob/rob_uop__12_rob_idx == 6'h18) && (soc2/core/rob/rob_uop__12_rob_idx == 6'h18) &&
  (soc1/core/rob/rob_uop__13_rob_idx == 6'h1a) && (soc2/core/rob/rob_uop__13_rob_idx == 6'h1a) &&
  (soc1/core/rob/rob_uop__14_rob_idx == 6'h1c) && (soc2/core/rob/rob_uop__14_rob_idx == 6'h1c) &&
  (soc1/core/rob/rob_uop__15_rob_idx == 6'h1e) && (soc2/core/rob/rob_uop__15_rob_idx == 6'h1e) &&
  (soc1/core/rob/rob_uop__16_rob_idx == 6'h20) && (soc2/core/rob/rob_uop__16_rob_idx == 6'h20) &&
  (soc1/core/rob/rob_uop__17_rob_idx == 6'h22) && (soc2/core/rob/rob_uop__17_rob_idx == 6'h22) &&
  (soc1/core/rob/rob_uop__18_rob_idx == 6'h24) && (soc2/core/rob/rob_uop__18_rob_idx == 6'h24) &&
  (soc1/core/rob/rob_uop__19_rob_idx == 6'h26) && (soc2/core/rob/rob_uop__19_rob_idx == 6'h26) &&
  (soc1/core/rob/rob_uop__20_rob_idx == 6'h28) && (soc2/core/rob/rob_uop__20_rob_idx == 6'h28) &&
  (soc1/core/rob/rob_uop__21_rob_idx == 6'h2a) && (soc2/core/rob/rob_uop__21_rob_idx == 6'h2a) &&
  (soc1/core/rob/rob_uop__22_rob_idx == 6'h2c) && (soc2/core/rob/rob_uop__22_rob_idx == 6'h2c) &&
  (soc1/core/rob/rob_uop__23_rob_idx == 6'h2e) && (soc2/core/rob/rob_uop__23_rob_idx == 6'h2e) &&
  (soc1/core/rob/rob_uop__24_rob_idx == 6'h30) && (soc2/core/rob/rob_uop__24_rob_idx == 6'h30) &&
  (soc1/core/rob/rob_uop__25_rob_idx == 6'h32) && (soc2/core/rob/rob_uop__25_rob_idx == 6'h32) &&
  (soc1/core/rob/rob_uop__26_rob_idx == 6'h34) && (soc2/core/rob/rob_uop__26_rob_idx == 6'h34) &&
  (soc1/core/rob/rob_uop__27_rob_idx == 6'h36) && (soc2/core/rob/rob_uop__27_rob_idx == 6'h36) &&
  (soc1/core/rob/rob_uop__28_rob_idx == 6'h38) && (soc2/core/rob/rob_uop__28_rob_idx == 6'h38) &&
  (soc1/core/rob/rob_uop__29_rob_idx == 6'h3a) && (soc2/core/rob/rob_uop__29_rob_idx == 6'h3a) &&
  (soc1/core/rob/rob_uop__30_rob_idx == 6'h3c) && (soc2/core/rob/rob_uop__30_rob_idx == 6'h3c) &&
  (soc1/core/rob/rob_uop__31_rob_idx == 6'h3e) && (soc2/core/rob/rob_uop__31_rob_idx == 6'h3e) &&

  (soc1/core/rob/rob_uop_1_0_rob_idx == 6'h1) && (soc2/core/rob/rob_uop_1_0_rob_idx == 6'h1) &&
  (soc1/core/rob/rob_uop_1_1_rob_idx == 6'h3) && (soc2/core/rob/rob_uop_1_1_rob_idx == 6'h3) &&
  (soc1/core/rob/rob_uop_1_2_rob_idx == 6'h5) && (soc2/core/rob/rob_uop_1_2_rob_idx == 6'h5) &&
  (soc1/core/rob/rob_uop_1_3_rob_idx == 6'h7) && (soc2/core/rob/rob_uop_1_3_rob_idx == 6'h7) &&
  (soc1/core/rob/rob_uop_1_4_rob_idx == 6'h9) && (soc2/core/rob/rob_uop_1_4_rob_idx == 6'h9) &&
  (soc1/core/rob/rob_uop_1_5_rob_idx == 6'hb) && (soc2/core/rob/rob_uop_1_5_rob_idx == 6'hb) &&
  (soc1/core/rob/rob_uop_1_6_rob_idx == 6'hd) && (soc2/core/rob/rob_uop_1_6_rob_idx == 6'hd) &&
  (soc1/core/rob/rob_uop_1_7_rob_idx == 6'hf) && (soc2/core/rob/rob_uop_1_7_rob_idx == 6'hf) &&
  (soc1/core/rob/rob_uop_1_8_rob_idx == 6'h11) && (soc2/core/rob/rob_uop_1_8_rob_idx == 6'h11) &&
  (soc1/core/rob/rob_uop_1_9_rob_idx == 6'h13) && (soc2/core/rob/rob_uop_1_9_rob_idx == 6'h13) &&
  (soc1/core/rob/rob_uop_1_10_rob_idx == 6'h15) && (soc2/core/rob/rob_uop_1_10_rob_idx == 6'h15) &&
  (soc1/core/rob/rob_uop_1_11_rob_idx == 6'h17) && (soc2/core/rob/rob_uop_1_11_rob_idx == 6'h17) &&
  (soc1/core/rob/rob_uop_1_12_rob_idx == 6'h19) && (soc2/core/rob/rob_uop_1_12_rob_idx == 6'h19) &&
  (soc1/core/rob/rob_uop_1_13_rob_idx == 6'h1b) && (soc2/core/rob/rob_uop_1_13_rob_idx == 6'h1b) &&
  (soc1/core/rob/rob_uop_1_14_rob_idx == 6'h1d) && (soc2/core/rob/rob_uop_1_14_rob_idx == 6'h1d) &&
  (soc1/core/rob/rob_uop_1_15_rob_idx == 6'h1f) && (soc2/core/rob/rob_uop_1_15_rob_idx == 6'h1f) &&
  (soc1/core/rob/rob_uop_1_16_rob_idx == 6'h21) && (soc2/core/rob/rob_uop_1_16_rob_idx == 6'h21) &&
  (soc1/core/rob/rob_uop_1_17_rob_idx == 6'h23) && (soc2/core/rob/rob_uop_1_17_rob_idx == 6'h23) &&
  (soc1/core/rob/rob_uop_1_18_rob_idx == 6'h25) && (soc2/core/rob/rob_uop_1_18_rob_idx == 6'h25) &&
  (soc1/core/rob/rob_uop_1_19_rob_idx == 6'h27) && (soc2/core/rob/rob_uop_1_19_rob_idx == 6'h27) &&
  (soc1/core/rob/rob_uop_1_20_rob_idx == 6'h29) && (soc2/core/rob/rob_uop_1_20_rob_idx == 6'h29) &&
  (soc1/core/rob/rob_uop_1_21_rob_idx == 6'h2b) && (soc2/core/rob/rob_uop_1_21_rob_idx == 6'h2b) &&
  (soc1/core/rob/rob_uop_1_22_rob_idx == 6'h2d) && (soc2/core/rob/rob_uop_1_22_rob_idx == 6'h2d) &&
  (soc1/core/rob/rob_uop_1_23_rob_idx == 6'h2f) && (soc2/core/rob/rob_uop_1_23_rob_idx == 6'h2f) &&
  (soc1/core/rob/rob_uop_1_24_rob_idx == 6'h31) && (soc2/core/rob/rob_uop_1_24_rob_idx == 6'h31) &&
  (soc1/core/rob/rob_uop_1_25_rob_idx == 6'h33) && (soc2/core/rob/rob_uop_1_25_rob_idx == 6'h33) &&
  (soc1/core/rob/rob_uop_1_26_rob_idx == 6'h35) && (soc2/core/rob/rob_uop_1_26_rob_idx == 6'h35) &&
  (soc1/core/rob/rob_uop_1_27_rob_idx == 6'h37) && (soc2/core/rob/rob_uop_1_27_rob_idx == 6'h37) &&
  (soc1/core/rob/rob_uop_1_28_rob_idx == 6'h39) && (soc2/core/rob/rob_uop_1_28_rob_idx == 6'h39) &&
  (soc1/core/rob/rob_uop_1_29_rob_idx == 6'h3b) && (soc2/core/rob/rob_uop_1_29_rob_idx == 6'h3b) &&
  (soc1/core/rob/rob_uop_1_30_rob_idx == 6'h3d) && (soc2/core/rob/rob_uop_1_30_rob_idx == 6'h3d) &&
  (soc1/core/rob/rob_uop_1_31_rob_idx == 6'h3f) && (soc2/core/rob/rob_uop_1_31_rob_idx == 6'h3f)
  ;
end macro;

macro boolean root_br_mispred :=
  ((soc1/core/brinfos_0_valid) && (soc1/core/brinfos_0_uop_rob_idx == root_id) ? soc1/core/brinfos_0_mispredict : 1'b1) &&
  ((soc1/core/brinfos_1_valid) && (soc1/core/brinfos_1_uop_rob_idx == root_id) ? soc1/core/brinfos_1_mispredict : 1'b1) &&
  ((soc2/core/brinfos_0_valid) && (soc2/core/brinfos_0_uop_rob_idx == root_id) ? soc2/core/brinfos_0_mispredict : 1'b1) &&
  ((soc2/core/brinfos_1_valid) && (soc2/core/brinfos_1_uop_rob_idx == root_id) ? soc2/core/brinfos_1_mispredict : 1'b1);
end macro;

macro boolean full_empty_logic :=
  (soc1/core/rob/io_rob_head_idx == soc1/core/rob/io_rob_tail_idx ? soc1/core/rob/full ^ soc1/core/rob/empty : 1'b1) &&
  (soc2/core/rob/io_rob_head_idx == soc2/core/rob/io_rob_tail_idx ? soc2/core/rob/full ^ soc2/core/rob/empty : 1'b1);
end macro;

macro boolean rob_full_pointers :=
	(soc1/core/rob/full ? (soc1/core/rob/io_rob_head_idx == soc1/core/rob/io_rob_tail_idx) || (soc1/core/rob/io_rob_head_idx == (soc1/core/rob/io_rob_tail_idx + 1) mod 64) : 1'b1) &&
	(soc2/core/rob/full ? (soc2/core/rob/io_rob_head_idx == soc2/core/rob/io_rob_tail_idx) || (soc2/core/rob/io_rob_head_idx == (soc2/core/rob/io_rob_tail_idx + 1) mod 64) : 1'b1);
end macro;

property ME_Invariant;
  dependencies: no_reset, br_tag_in_bounds;

  assume:
  
    //UPEC assumptions
    
    during[t, t+L]: blackboxing;

    at t: state_equivalence;

    during[t, t+L-1]: microequivalence == 1'b1;

    //assumptions needed for microequivalence scenario
    
    during[t, t+L]: br_tag_protection == 1'b1;

    during[t, t+L]: enqueue_uncom_br_tags == 1'b1;

    during[t, t+L]: root_br_mispred == 1'b1;

    during[t, t+L]: consistent_uncommittable_masks == 1'b1;
    
    during[t, t+L]: st_dep_mask_consistency == 1'b1;
    
    at t: init_mispred_signals;

    during[t, t+L]: secret_data_protected;

    //pure functional assumptions, checked with simulation
    
    during[t, t+L]: (consistent_valid_flags_1 && consistent_valid_flags_2) == 1'b1;

    during[t, t+L]: (consistent_tail_rollback_1 && consistent_tail_rollback_2) == 1'b1;

    during[t, t+L]: (full_empty_logic_1 && full_empty_logic_2 && empty_logic_1 && empty_logic_2 && full_logic_1 && full_logic_2) == 1'b1;
    
    during[t, t+L]: (valid_issue_slots_1 && valid_mispred_idx_1 && valid_iregister_read_1 && valid_issue_slots_2 && valid_mispred_idx_2 && valid_iregister_read_2) == 1'b1;

    during[t, t+L]: (no_speculative_head_1 && no_speculative_head_2) == 1'b1;

    during[t, t+L]: (no_speculative_commit_1 && no_speculative_commit_2) == 1'b1;

    during[t, t+L]: (ldq_check_invalidated_entries_1 && ldq_check_invalidated_entries_2 && stq_check_invalidated_entries_1 && stq_check_invalidated_entries_2) == 1'b1;
    
    during[t, t+L]: (consistent_branch_masks_1 && consistent_branch_masks_2) == 1'b1;
    
    during[t, t+L]: (consistent_buffer_br_masks_1 && consistent_buffer_br_masks_2) == 1'b1;
    
    during[t, t+L]: (prevent_overwriting_valid_entries_1 && prevent_overwriting_valid_entries_2) == 1'b1;
    
    during[t, t+L]: addr_index_in_bounds == 1'b1;
    
    during[t, t+L]: (lcam_ldq_idx_valid_1 && lcam_ldq_idx_valid_2 && lcam_stq_idx_valid_1 && lcam_stq_idx_valid_2) == 1'b1;
    
    during[t, t+L]: (ldq_consistent_rob_idx_1 && ldq_consistent_rob_idx_2 && stq_consistent_rob_idx_1 && stq_consistent_rob_idx_2) == 1'b1;
    
    during[t, t+L]: (consistent_stq_committed_1 && consistent_stq_committed_2) == 1'b1;
    
    during[t, t+L]: (committed_stores_not_speculative_1 && committed_stores_not_speculative_2) == 1'b1;
    
    during[t, t+L]: (!speculative_store_rpq_1 && !speculative_store_rpq_2) == 1'b1;
    
    during[t, t+L]: (!speculative_store_s1_s2_1 && !speculative_store_s1_s2_2) == 1'b1;
            
    during[t, t+L]: (fpiu_BranchKillableQueue_1_not_committed_1 && fpiu_BranchKillableQueue_1_not_committed_2) == 1'b1;
    
    during[t, t+L]: (fdivsqrt_valid_consistency_1 && fdivsqrt_valid_consistency_2) == 1'b1;
    
    during[t, t+L]: (div_state_1 && div_state_2) == 1'b1;
    
    during[t, t+L]: (ldq_entries_not_using_stq_1 && ldq_entries_not_using_stq_2 && stq_entries_not_using_ldq_1 && stq_entries_not_using_ldq_2) == 1'b1;
    
    during[t, t+L]: (BranchKillableQueue_empty_1 && BranchKillableQueue_empty_2) == 1'b1;
    
    during[t, t+L]: (BranchKillableQueue_pointers_valid_1 && BranchKillableQueue_pointers_valid_2) == 1'b1;
    
    during[t, t+L]: (buffers_equal_ROB_1 && buffers_equal_ROB_2) == 1'b1;
    
    during[t, t+L]: (unique_stq_idx_1 && unique_stq_idx_2) == 1'b1;
    
    during[t, t+L]: (ROB_uops_equal_STQ_1 && ROB_uops_equal_STQ_2 && ROB_uops_equal_LDQ_1 && ROB_uops_equal_LDQ_2 && STQ_uops_equals_ROB_1 && STQ_uops_equals_ROB_2 && LDQ_uops_equals_ROB_1 && LDQ_uops_equals_ROB_2) == 1'b1;
    
    during[t, t+L]: (stdf_clr_bsy_uses_stq_1 && stdf_clr_bsy_uses_stq_2) == 1'b1;
    
    //currently unused
    //during[t, t+L]: rob_full_pointers;

    //during[t, t+L]: root_commits_after_misprediction == 1'b1;    
    
    //during[t, t+L]: com_mispred_kills_root == 1'b1;
    
    //during[t, t+L]: rob_idx_correctly_set == 1'b1;

    //during[t, t+L]: consistent_lsu_rob_idx == 1'b1;
        
  prove:

    at t+L: microequivalence == 1'b1;

end property;

property UPEC_boom;
	dependencies: no_reset, br_tag_in_bounds;

	assume:
		during[t, t+K]: blackboxing;

		during[t, t+K]: secret_data_protected;

		at t: state_equivalence;

		at t: init_mispred_signals;

		during[t, t+K]: microequivalence == 1'b1;

		during[t, t+K]: soc1/core/csr/reg_wfi == soc2/core/csr/reg_wfi;

		during[t, t+K]: csr_insn_cease_equal == 1'b1;

		during[t, t+K]: st_dep_mask_consistency == 1'b1;

		//during[t, t+K]: consistent_lsu_rob_idx == 1'b1;

    		//during[t, t+K]: rob_idx_correctly_set == 1'b1;

		during[t, t+K]: (consistent_branch_masks_1 && consistent_branch_masks_2) == 1'b1;

		during[t, t+K]: (consistent_buffer_br_masks_1 && consistent_buffer_br_masks_2) == 1'b1;

		during[t, t+K]: (consistent_tail_rollback_1 && consistent_tail_rollback_2) == 1'b1;

		during[t, t+K]: (ldq_check_invalidated_entries_1 && ldq_check_invalidated_entries_2 && stq_check_invalidated_entries_1 && stq_check_invalidated_entries_2) == 1'b1;

		during[t, t+K]: (full_empty_logic_1 && full_empty_logic_2 && empty_logic_1 && empty_logic_2 && full_logic_1 && full_logic_2) == 1'b1;

		during[t, t+K]: (consistent_valid_flags_1 && consistent_valid_flags_2) == 1'b1;
    
		during[t, t+K]: (no_speculative_head_1 && no_speculative_head_2) == 1'b1;

		during[t, t+K]: (no_speculative_commit_1 && no_speculative_commit_2) == 1'b1;
		
	        during[t, t+K]: (lcam_ldq_idx_valid_1 && lcam_ldq_idx_valid_2 && lcam_stq_idx_valid_1 && lcam_stq_idx_valid_2) == 1'b1;
	        
	        during[t, t+K]: (ldq_consistent_rob_idx_1 && ldq_consistent_rob_idx_2 && stq_consistent_rob_idx_1 && stq_consistent_rob_idx_2) == 1'b1;
	         
	        during[t, t+K]: (consistent_stq_committed_1 && consistent_stq_committed_2) == 1'b1;
    
		during[t, t+K]: (committed_stores_not_speculative_1 && committed_stores_not_speculative_2) == 1'b1;
		
		during[t, t+K]: (!speculative_store_rpq_1 && !speculative_store_rpq_2) == 1'b1;
    
   		during[t, t+K]: (!speculative_store_s1_s2_1 && !speculative_store_s1_s2_2) == 1'b1;

		during[t, t+K]: (fpiu_BranchKillableQueue_1_not_committed_1 && fpiu_BranchKillableQueue_1_not_committed_2) == 1'b1;
		
		during[t, t+K]: (fdivsqrt_valid_consistency_1 && fdivsqrt_valid_consistency_2) == 1'b1;
		
		during[t, t+K]: (div_state_1 && div_state_2) == 1'b1;
		
		during[t, t+K]: (ldq_entries_not_using_stq_1 && ldq_entries_not_using_stq_2 && stq_entries_not_using_ldq_1 && stq_entries_not_using_ldq_2) == 1'b1;
		
		during[t, t+K]: (ROB_uops_equal_STQ_1 && ROB_uops_equal_STQ_2 && ROB_uops_equal_LDQ_1 && ROB_uops_equal_LDQ_2 && STQ_uops_equals_ROB_1 && STQ_uops_equals_ROB_2 && LDQ_uops_equals_ROB_1 && LDQ_uops_equals_ROB_2) == 1'b1;
		
		//during[t, t+K]: com_mispred_kills_root == 1'b1;

		//during[t, t+K]: enqueue_uncom_br_tags == 1'b1;

		//during[t, t+K]: root_br_mispred == 1'b1;

		during[t, t+K]: (valid_issue_slots_1 && valid_mispred_idx_1 && valid_iregister_read_1 && valid_issue_slots_2 && valid_mispred_idx_2 && valid_iregister_read_2) == 1'b1;
    
		//during[t, t+K]: addr_index_in_bounds == 1'b1;

		during[t, t+K]: br_tag_protection == 1'b1;
		
	    	during[t, t+K]: consistent_uncommittable_masks == 1'b1;
	    	
	    	during[t, t+K]: (BranchKillableQueue_empty_1 && BranchKillableQueue_empty_2) == 1'b1;

	    	during[t, t+K]: (BranchKillableQueue_pointers_valid_1 && BranchKillableQueue_pointers_valid_2) == 1'b1;
	    	  
		//during[t, t+K]: (bkq_jmp_rob_consistency_1 && bkq_jmp_rob_consistency_2 && bkq_fp_rob_consistency_1 && bkq_fp_rob_consistency_2 && bkq_fp_1_rob_consistency_1 && bkq_fp_1_rob_consistency_2) == 1'b1;
	    	
    		during[t, t+K]: (buffers_equal_ROB_1 && buffers_equal_ROB_2) == 1'b1;
    		
    		during[t, t+K]: (unique_stq_idx_1 && unique_stq_idx_2) == 1'b1;
    		
	        during[t, t+K]: (stdf_clr_bsy_uses_stq_1 && stdf_clr_bsy_uses_stq_2) == 1'b1;
	        	   
		during[t, t+K]: (prevent_overwriting_valid_entries_1 && prevent_overwriting_valid_entries_2) == 1'b1;
	    	
		//excluded attacks

		during[t, t+K]: soc1/core/fp_pipeline/fpiu_unit/fpu_io_resp_valid == soc2/core/fp_pipeline/fpiu_unit/fpu_io_resp_valid;

		during[t, t+K]: soc1/core/ll_wbarb/io_in_0_valid == soc2/core/ll_wbarb/io_in_0_valid;

		during[t, t+K]: soc1/core/fp_pipeline/fpiu_unit/Arbiter/io_in_0_valid == soc2/core/fp_pipeline/fpiu_unit/Arbiter/io_in_0_valid;

		during[t, t+K]: soc1/core/fp_pipeline/ll_wbarb/io_in_0_valid == soc2/core/fp_pipeline/ll_wbarb/io_in_0_valid;

		during[t, t+K]: soc1/core/csr_exe_unit/alu_io_resp_valid == soc2/core/csr_exe_unit/alu_io_resp_valid;

		during[t, t+K]: cache_resp_equal == 1'b1;

		during[t, t+K]: uncache_resp_equal == 1'b1;

		during[t, t+K]: wb_forward_valid_equal == 1'b1;

		during[t, t+K]: dmem_resp_fired_equal == 1'b1;

		during[t, t+K]: mshrs_resp_arb_valid_equal == 1'b1;

		during[t, t+K]: dis_hazards_equal == 1'b1;
		
		//port contention between stores and fp_stores with static priority
		during[t, t+K]: soc1/lsu/io_core_fp_stdata_ready == soc2/lsu/io_core_fp_stdata_ready;
		
		//port contention in jmp_unit between alu and imul (static priority)
		during[t, t+K]: soc1/core/jmp_unit/alu_io_resp_valid == soc2/core/jmp_unit/alu_io_resp_valid;
		
		//port contention on LSU port to memory (static priority)
		during[t, t+K]: soc1/lsu/fired_load_incoming_0 == soc2/lsu/fired_load_incoming_0 &&
				soc1/lsu/fired_stad_incoming_0 == soc2/lsu/fired_stad_incoming_0 &&
				soc1/lsu/fired_sta_incoming_0 == soc2/lsu/fired_sta_incoming_0 &&
				soc1/lsu/fired_std_incoming_0 == soc2/lsu/fired_std_incoming_0 &&
				soc1/lsu/fired_stdf_incoming == soc2/lsu/fired_stdf_incoming &&
				soc1/lsu/fired_sfence_0 == soc2/lsu/fired_sfence_0 &&
				soc1/lsu/fired_release_0 == soc2/lsu/fired_release_0 &&
				soc1/lsu/fired_load_retry_0 == soc2/lsu/fired_load_retry_0 &&
				soc1/lsu/fired_sta_retry_0 == soc2/lsu/fired_sta_retry_0 &&
				soc1/lsu/will_fire_store_commit_0 == soc2/lsu/will_fire_store_commit_0 &&
				soc1/lsu/fired_load_wakeup_0 == soc2/lsu/fired_load_wakeup_0 &&
				soc1/lsu/will_fire_hella_incoming_0 == soc2/lsu/will_fire_hella_incoming_0 &&
				soc1/lsu/will_fire_hella_wakeup_0 == soc2/lsu/will_fire_hella_wakeup_0
				;
				
		//fixed priority arbitration for output of BranchKillableQueues because of "flow queue" behaviour (if queue empty, input can directly go to output)
		during[t, t+K]: soc1/core/jmp_unit/BranchKillableQueue/io_empty == soc2/core/jmp_unit/BranchKillableQueue/io_empty &&
				soc1/core/fp_pipeline/fpiu_unit/BranchKillableQueue/io_empty == soc2/core/fp_pipeline/fpiu_unit/BranchKillableQueue/io_empty &&
				soc1/core/fp_pipeline/fpiu_unit/BranchKillableQueue_1/io_empty == soc2/core/fp_pipeline/fpiu_unit/BranchKillableQueue_1/io_empty;

	prove:
		at t+K: lAlert == 1'b0 /*&& lAlert_earlyAlarm == 1'b0*/;

end property;

property UPEC_boom_equal_mispredicts;
	dependencies: no_reset, br_tag_in_bounds;

	assume:
		during[t, t+N]: blackboxing;

		during[t, t+N]: secret_data_protected;

		at t: state_equivalence;

		at t: init_mispred_signals;

		during[t, t+N]: microequivalence == 1'b1;

		during[t, t+N]: soc1/core/csr/reg_wfi == soc2/core/csr/reg_wfi;

		during[t, t+N]: csr_insn_cease_equal == 1'b1;

		during[t, t+N]: st_dep_mask_consistency == 1'b1;

		//during[t, t+N]: consistent_lsu_rob_idx == 1'b1;

    		//during[t, t+N]: rob_idx_correctly_set == 1'b1;

		during[t, t+N]: (consistent_branch_masks_1 && consistent_branch_masks_2) == 1'b1;

		during[t, t+N]: (consistent_buffer_br_masks_1 && consistent_buffer_br_masks_2) == 1'b1;

		during[t, t+N]: (consistent_tail_rollback_1 && consistent_tail_rollback_2) == 1'b1;

		during[t, t+N]: (ldq_check_invalidated_entries_1 && ldq_check_invalidated_entries_2 && stq_check_invalidated_entries_1 && stq_check_invalidated_entries_2) == 1'b1;

		during[t, t+N]: (full_empty_logic_1 && full_empty_logic_2 && empty_logic_1 && empty_logic_2 && full_logic_1 && full_logic_2) == 1'b1;

		during[t, t+N]: (consistent_valid_flags_1 && consistent_valid_flags_2) == 1'b1;
    
		during[t, t+N]: (no_speculative_head_1 && no_speculative_head_2) == 1'b1;

		during[t, t+N]: (no_speculative_commit_1 && no_speculative_commit_2) == 1'b1;
		
	        during[t, t+N]: (lcam_ldq_idx_valid_1 && lcam_ldq_idx_valid_2 && lcam_stq_idx_valid_1 && lcam_stq_idx_valid_2) == 1'b1;
	        
	        during[t, t+N]: (ldq_consistent_rob_idx_1 && ldq_consistent_rob_idx_2 && stq_consistent_rob_idx_1 && stq_consistent_rob_idx_2) == 1'b1;
	         
	        during[t, t+N]: (consistent_stq_committed_1 && consistent_stq_committed_2) == 1'b1;
    
		during[t, t+N]: (committed_stores_not_speculative_1 && committed_stores_not_speculative_2) == 1'b1;
		
		during[t, t+N]: (!speculative_store_rpq_1 && !speculative_store_rpq_2) == 1'b1;
    
   		during[t, t+N]: (!speculative_store_s1_s2_1 && !speculative_store_s1_s2_2) == 1'b1;

		during[t, t+N]: (fpiu_BranchKillableQueue_1_not_committed_1 && fpiu_BranchKillableQueue_1_not_committed_2) == 1'b1;
		
		during[t, t+N]: (fdivsqrt_valid_consistency_1 && fdivsqrt_valid_consistency_2) == 1'b1;
		
		during[t, t+N]: (div_state_1 && div_state_2) == 1'b1;
		
		during[t, t+N]: (ldq_entries_not_using_stq_1 && ldq_entries_not_using_stq_2 && stq_entries_not_using_ldq_1 && stq_entries_not_using_ldq_2) == 1'b1;
		
		during[t, t+N]: (ROB_uops_equal_STQ_1 && ROB_uops_equal_STQ_2 && ROB_uops_equal_LDQ_1 && ROB_uops_equal_LDQ_2 && STQ_uops_equals_ROB_1 && STQ_uops_equals_ROB_2 && LDQ_uops_equals_ROB_1 && LDQ_uops_equals_ROB_2) == 1'b1;
		
		//during[t, t+N]: com_mispred_kills_root == 1'b1;

		//during[t, t+N]: enqueue_uncom_br_tags == 1'b1;

		//during[t, t+N]: root_br_mispred == 1'b1;

		during[t, t+N]: (valid_issue_slots_1 && valid_mispred_idx_1 && valid_iregister_read_1 && valid_issue_slots_2 && valid_mispred_idx_2 && valid_iregister_read_2) == 1'b1;
    
		//during[t, t+N]: addr_index_in_bounds == 1'b1;

		during[t, t+N]: br_tag_protection == 1'b1;
		
	    	during[t, t+N]: consistent_uncommittable_masks == 1'b1;
	    	
	    	during[t, t+N]: (BranchKillableQueue_empty_1 && BranchKillableQueue_empty_2) == 1'b1;
	    	
	    	during[t, t+N]: (BranchKillableQueue_pointers_valid_1 && BranchKillableQueue_pointers_valid_2) == 1'b1;
	    	
		//during[t, t+N]: (bkq_jmp_rob_consistency_1 && bkq_jmp_rob_consistency_2 && bkq_fp_rob_consistency_1 && bkq_fp_rob_consistency_2 && bkq_fp_1_rob_consistency_1 && bkq_fp_1_rob_consistency_2) == 1'b1;

    		during[t, t+N]: (buffers_equal_ROB_1 && buffers_equal_ROB_2) == 1'b1;
    		
    		during[t, t+N]: (unique_stq_idx_1 && unique_stq_idx_2) == 1'b1;
    		
	        during[t, t+N]: (stdf_clr_bsy_uses_stq_1 && stdf_clr_bsy_uses_stq_2) == 1'b1;
	        
		during[t, t+N]: (prevent_overwriting_valid_entries_1 && prevent_overwriting_valid_entries_2) == 1'b1;

		//excluded attacks

		during[t, t+N]: soc1/core/fp_pipeline/fpiu_unit/fpu_io_resp_valid == soc2/core/fp_pipeline/fpiu_unit/fpu_io_resp_valid;

		during[t, t+N]: soc1/core/ll_wbarb/io_in_0_valid == soc2/core/ll_wbarb/io_in_0_valid;

		during[t, t+N]: soc1/core/fp_pipeline/fpiu_unit/Arbiter/io_in_0_valid == soc2/core/fp_pipeline/fpiu_unit/Arbiter/io_in_0_valid;

		during[t, t+K]: soc1/core/fp_pipeline/ll_wbarb/io_in_0_valid == soc2/core/fp_pipeline/ll_wbarb/io_in_0_valid;

		during[t, t+N]: soc1/core/csr_exe_unit/alu_io_resp_valid == soc2/core/csr_exe_unit/alu_io_resp_valid;

		during[t, t+N]: cache_resp_equal == 1'b1;

		during[t, t+N]: uncache_resp_equal == 1'b1;

		during[t, t+N]: wb_forward_valid_equal == 1'b1;

		during[t, t+N]: dmem_resp_fired_equal == 1'b1;

		during[t, t+N]: mshrs_resp_arb_valid_equal == 1'b1;

		during[t, t+N]: dis_hazards_equal == 1'b1;
		
		//port contention between stores and fp_stores with static priority
		during[t, t+N]: soc1/lsu/io_core_fp_stdata_ready == soc2/lsu/io_core_fp_stdata_ready;
		
		//port contention in jmp_unit between alu and imul (static priority)
		during[t, t+N]: soc1/core/jmp_unit/alu_io_resp_valid == soc2/core/jmp_unit/alu_io_resp_valid;
		
		//port contention on LSU port to memory (static priority)
		during[t, t+N]: soc1/lsu/fired_load_incoming_0 == soc2/lsu/fired_load_incoming_0 &&
				soc1/lsu/fired_stad_incoming_0 == soc2/lsu/fired_stad_incoming_0 &&
				soc1/lsu/fired_sta_incoming_0 == soc2/lsu/fired_sta_incoming_0 &&
				soc1/lsu/fired_std_incoming_0 == soc2/lsu/fired_std_incoming_0 &&
				soc1/lsu/fired_stdf_incoming == soc2/lsu/fired_stdf_incoming &&
				soc1/lsu/fired_sfence_0 == soc2/lsu/fired_sfence_0 &&
				soc1/lsu/fired_release_0 == soc2/lsu/fired_release_0 &&
				soc1/lsu/fired_load_retry_0 == soc2/lsu/fired_load_retry_0 &&
				soc1/lsu/fired_sta_retry_0 == soc2/lsu/fired_sta_retry_0 &&
				soc1/lsu/will_fire_store_commit_0 == soc2/lsu/will_fire_store_commit_0 &&
				soc1/lsu/fired_load_wakeup_0 == soc2/lsu/fired_load_wakeup_0 &&
				soc1/lsu/will_fire_hella_incoming_0 == soc2/lsu/will_fire_hella_incoming_0 &&
				soc1/lsu/will_fire_hella_wakeup_0 == soc2/lsu/will_fire_hella_wakeup_0
				;
		
		//fixed priority arbitration for output of BranchKillableQueues because of "flow queue" behaviour (if queue empty, input can directly go to output)
		during[t, t+N]: soc1/core/jmp_unit/BranchKillableQueue/io_empty == soc2/core/jmp_unit/BranchKillableQueue/io_empty &&
				soc1/core/fp_pipeline/fpiu_unit/BranchKillableQueue/io_empty == soc2/core/fp_pipeline/fpiu_unit/BranchKillableQueue/io_empty &&
				soc1/core/fp_pipeline/fpiu_unit/BranchKillableQueue_1/io_empty == soc2/core/fp_pipeline/fpiu_unit/BranchKillableQueue_1/io_empty;
		
		during[t, t+N]: equal_mispredicts;

	prove:
		at t+N: lAlert == 1'b0 /*&& lAlert_earlyAlarm == 1'b0*/;

end property;

macro integer M := 4; end macro;

property L_alerts_from_mispredict;
	dependencies: no_reset, br_tag_in_bounds;

	assume:
		during[t, t+M]: blackboxing;

		during[t, t+M]: secret_data_protected;

		at t: state_equivalence_branch_mispredict_excluded;

		at t: init_mispred_signals;

		during[t, t+M]: microequivalence == 1'b1;
		
		during[t, t+M]: soc1/core/csr/reg_wfi == soc2/core/csr/reg_wfi;

		during[t, t+M]: csr_insn_cease_equal == 1'b1;

		during[t, t+M]: st_dep_mask_consistency == 1'b1;

		//during[t, t+M]: consistent_lsu_rob_idx == 1'b1;

    		//during[t, t+M]: rob_idx_correctly_set == 1'b1;

		during[t, t+M]: (consistent_branch_masks_1 && consistent_branch_masks_2) == 1'b1;

		during[t, t+M]: (consistent_buffer_br_masks_1 && consistent_buffer_br_masks_2) == 1'b1;

		during[t, t+M]: (consistent_tail_rollback_1 && consistent_tail_rollback_2) == 1'b1;

		during[t, t+M]: (ldq_check_invalidated_entries_1 && ldq_check_invalidated_entries_2 && stq_check_invalidated_entries_1 && stq_check_invalidated_entries_2) == 1'b1;

		during[t, t+M]: (full_empty_logic_1 && full_empty_logic_2 && empty_logic_1 && empty_logic_2 && full_logic_1 && full_logic_2) == 1'b1;

		during[t, t+M]: (consistent_valid_flags_1 && consistent_valid_flags_2) == 1'b1;
    
		during[t, t+M]: (no_speculative_head_1 && no_speculative_head_2) == 1'b1;

		during[t, t+M]: (no_speculative_commit_1 && no_speculative_commit_2) == 1'b1;
		
	        during[t, t+M]: (lcam_ldq_idx_valid_1 && lcam_ldq_idx_valid_2 && lcam_stq_idx_valid_1 && lcam_stq_idx_valid_2) == 1'b1;
	        
	        during[t, t+M]: (ldq_consistent_rob_idx_1 && ldq_consistent_rob_idx_2 && stq_consistent_rob_idx_1 && stq_consistent_rob_idx_2) == 1'b1;
	         
	        during[t, t+M]: (consistent_stq_committed_1 && consistent_stq_committed_2) == 1'b1;
    
		during[t, t+M]: (committed_stores_not_speculative_1 && committed_stores_not_speculative_2) == 1'b1;
		
		during[t, t+M]: (!speculative_store_rpq_1 && !speculative_store_rpq_2) == 1'b1;
    
   		during[t, t+M]: (!speculative_store_s1_s2_1 && !speculative_store_s1_s2_2) == 1'b1;

		during[t, t+M]: (fpiu_BranchKillableQueue_1_not_committed_1 && fpiu_BranchKillableQueue_1_not_committed_2) == 1'b1;
		
		during[t, t+M]: (fdivsqrt_valid_consistency_1 && fdivsqrt_valid_consistency_2) == 1'b1;
		
		during[t, t+M]: (div_state_1 && div_state_2) == 1'b1;
		
		during[t, t+M]: (ldq_entries_not_using_stq_1 && ldq_entries_not_using_stq_2 && stq_entries_not_using_ldq_1 && stq_entries_not_using_ldq_2) == 1'b1;
		
		during[t, t+M]: (ROB_uops_equal_STQ_1 && ROB_uops_equal_STQ_2 && ROB_uops_equal_LDQ_1 && ROB_uops_equal_LDQ_2 && STQ_uops_equals_ROB_1 && STQ_uops_equals_ROB_2 && LDQ_uops_equals_ROB_1 && LDQ_uops_equals_ROB_2) == 1'b1;
		
		during[t, t+M]: (prevent_overwriting_valid_entries_1 && prevent_overwriting_valid_entries_2) == 1'b1;
		
		//during[t, t+M]: com_mispred_kills_root == 1'b1;

		//during[t, t+M]: enqueue_uncom_br_tags == 1'b1;

		//during[t, t+M]: root_br_mispred == 1'b1;

		//during[t, t+M]: (bkq_jmp_rob_consistency_1 && bkq_jmp_rob_consistency_2 && bkq_fp_rob_consistency_1 && bkq_fp_rob_consistency_2 && bkq_fp_1_rob_consistency_1 && bkq_fp_1_rob_consistency_2) == 1'b1;
    
    		during[t, t+M]: (buffers_equal_ROB_1 && buffers_equal_ROB_2) == 1'b1;
    		
    		during[t, t+M]: (unique_stq_idx_1 && unique_stq_idx_2) == 1'b1;
    		
	        during[t, t+M]: (stdf_clr_bsy_uses_stq_1 && stdf_clr_bsy_uses_stq_2) == 1'b1;
    		
		//during[t, t+M]: addr_index_in_bounds == 1'b1;

		during[t, t+M]: br_tag_protection == 1'b1;
		
	    	during[t, t+M]: consistent_uncommittable_masks == 1'b1;
	    	
	    	during[t, t+M]: (BranchKillableQueue_empty_1 && BranchKillableQueue_empty_2) == 1'b1;
	    	
	    	during[t, t+M]: (BranchKillableQueue_pointers_valid_1 && BranchKillableQueue_pointers_valid_2) == 1'b1;
	    	
		during[t, t+M]: (valid_issue_slots_1 && valid_mispred_idx_1 && valid_iregister_read_1 && valid_issue_slots_2 && valid_mispred_idx_2 && valid_iregister_read_2) == 1'b1;
		
	    	during[t, t+M]: (fdivsqrt_consistency_1 && fdivsqrt_consistency_2) == 1'b1;
	    	
	    	//use chisel assertion from fdiv.scala line 134
	    	during[t, t+M]: (soc1/core/fp_pipeline/fpiu_unit/fdivsqrt/_T_135 && soc2/core/fp_pipeline/fpiu_unit/fdivsqrt/_T_135) == 1'b1;

		//excluded attacks

		during[t, t+M]: soc1/core/fp_pipeline/fpiu_unit/fpu_io_resp_valid == soc2/core/fp_pipeline/fpiu_unit/fpu_io_resp_valid;

		during[t, t+M]: soc1/core/ll_wbarb/io_in_0_valid == soc2/core/ll_wbarb/io_in_0_valid;

		during[t, t+M]: soc1/core/fp_pipeline/fpiu_unit/Arbiter/io_in_0_valid == soc2/core/fp_pipeline/fpiu_unit/Arbiter/io_in_0_valid;

		during[t, t+M]: soc1/core/fp_pipeline/ll_wbarb/io_in_0_valid == soc2/core/fp_pipeline/ll_wbarb/io_in_0_valid;

		during[t, t+M]: soc1/core/csr_exe_unit/alu_io_resp_valid == soc2/core/csr_exe_unit/alu_io_resp_valid;

		during[t, t+M]: cache_resp_equal == 1'b1;

		during[t, t+M]: uncache_resp_equal == 1'b1;

		during[t, t+M]: wb_forward_valid_equal == 1'b1;

		during[t, t+M]: dmem_resp_fired_equal == 1'b1;

		during[t, t+M]: mshrs_resp_arb_valid_equal == 1'b1;

		during[t, t+M]: dis_hazards_equal == 1'b1;
		
		//port contention between stores and fp_stores with static priority
		during[t, t+M]: soc1/lsu/io_core_fp_stdata_ready == soc2/lsu/io_core_fp_stdata_ready;
		
		//port contention in jmp_unit between alu and imul (static priority)
		during[t, t+M]: soc1/core/jmp_unit/alu_io_resp_valid == soc2/core/jmp_unit/alu_io_resp_valid;
		
		//port contention on LSU port to memory (static priority)
		during[t, t+M]: soc1/lsu/fired_load_incoming_0 == soc2/lsu/fired_load_incoming_0 &&
				soc1/lsu/fired_stad_incoming_0 == soc2/lsu/fired_stad_incoming_0 &&
				soc1/lsu/fired_sta_incoming_0 == soc2/lsu/fired_sta_incoming_0 &&
				soc1/lsu/fired_std_incoming_0 == soc2/lsu/fired_std_incoming_0 &&
				soc1/lsu/fired_stdf_incoming == soc2/lsu/fired_stdf_incoming &&
				soc1/lsu/fired_sfence_0 == soc2/lsu/fired_sfence_0 &&
				soc1/lsu/fired_release_0 == soc2/lsu/fired_release_0 &&
				soc1/lsu/fired_load_retry_0 == soc2/lsu/fired_load_retry_0 &&
				soc1/lsu/fired_sta_retry_0 == soc2/lsu/fired_sta_retry_0 &&
				soc1/lsu/will_fire_store_commit_0 == soc2/lsu/will_fire_store_commit_0 &&
				soc1/lsu/fired_load_wakeup_0 == soc2/lsu/fired_load_wakeup_0 &&
				soc1/lsu/will_fire_hella_incoming_0 == soc2/lsu/will_fire_hella_incoming_0 &&
				soc1/lsu/will_fire_hella_wakeup_0 == soc2/lsu/will_fire_hella_wakeup_0
				;
				
		//fixed priority arbitration for output of BranchKillableQueues because of "flow queue" behaviour (if queue empty, input can directly go to output)
		during[t, t+M]: soc1/core/jmp_unit/BranchKillableQueue/io_empty == soc2/core/jmp_unit/BranchKillableQueue/io_empty &&
				soc1/core/fp_pipeline/fpiu_unit/BranchKillableQueue/io_empty == soc2/core/fp_pipeline/fpiu_unit/BranchKillableQueue/io_empty &&
				soc1/core/fp_pipeline/fpiu_unit/BranchKillableQueue_1/io_empty == soc2/core/fp_pipeline/fpiu_unit/BranchKillableQueue_1/io_empty;
		
		//fixed "priority" in LSU for handling dmem response
		during[t, t+M]: soc1/lsu/io_dmem_resp_0_bits_uop_uses_ldq == soc2/lsu/io_dmem_resp_0_bits_uop_uses_ldq && soc1/lsu/io_dmem_resp_0_bits_uop_uses_stq == soc2/lsu/io_dmem_resp_0_bits_uop_uses_stq;
		
		
		//fixed priority arbitration for replay arbiter in mshrs
		during[t, t+M]: soc1/dcache/mshrs/replay_arb/io_in_0_valid == soc2/dcache/mshrs/replay_arb/io_in_0_valid;
		during[t, t+M]: soc1/dcache/mshrs/replay_arb/io_in_1_valid == soc2/dcache/mshrs/replay_arb/io_in_1_valid;
		
		//fixed priority arbitration for dataRead arbiter in dcache
		during[t, t+M]: soc1/dcache/dataReadArb/io_in_0_valid == soc2/dcache/dataReadArb/io_in_0_valid;
		during[t, t+M]: soc1/dcache/dataReadArb/io_in_1_valid == soc2/dcache/dataReadArb/io_in_1_valid;
		during[t, t+M]: soc1/dcache/dataReadArb/io_in_2_valid == soc2/dcache/dataReadArb/io_in_2_valid;
		
		//fixed priority arbitration for metaRead arbiter in dcache
		during[t, t+M]: soc1/dcache/metaReadArb/io_in_0_valid == soc2/dcache/metaReadArb/io_in_0_valid;
		during[t, t+M]: soc1/dcache/metaReadArb/io_in_1_valid == soc2/dcache/metaReadArb/io_in_1_valid;
		during[t, t+M]: soc1/dcache/metaReadArb/io_in_2_valid == soc2/dcache/metaReadArb/io_in_2_valid;
		during[t, t+M]: soc1/dcache/metaReadArb/io_in_3_valid == soc2/dcache/metaReadArb/io_in_3_valid;
		during[t, t+M]: soc1/dcache/metaReadArb/io_in_4_valid == soc2/dcache/metaReadArb/io_in_4_valid;
		
		//if mispredict rob_idx is committable, mispredict signals have to be equal, else they can differ
		during[t, t+M]: uncom_branch_resolution == 1'b1;

	prove:

		at t+M: lAlert == 1'b0 /*&& lAlert_earlyAlarm == 1'b0*/;


end property;

property UPEC_symbolic_commitment;
	dependencies: no_reset, br_tag_in_bounds;

	assume:
		during[t, t+O]: blackboxing;

		during[t, t+O]: secret_data_protected;

		at t: state_equivalence_branch_mispredict_excluded;

		at t: init_mispred_signals;

		during[t, t+O]: microequivalence == 1'b1;
		
		during[t, t+O]: soc1/core/csr/reg_wfi == soc2/core/csr/reg_wfi;

		during[t, t+O]: csr_insn_cease_equal == 1'b1;

		during[t, t+O]: st_dep_mask_consistency == 1'b1;

		//during[t, t+O]: consistent_lsu_rob_idx == 1'b1;

    		//during[t, t+O]: rob_idx_correctly_set == 1'b1;

		during[t, t+O]: (consistent_branch_masks_1 && consistent_branch_masks_2) == 1'b1;

		during[t, t+O]: (consistent_buffer_br_masks_1 && consistent_buffer_br_masks_2) == 1'b1;

		during[t, t+O]: (consistent_tail_rollback_1 && consistent_tail_rollback_2) == 1'b1;

		during[t, t+O]: (ldq_check_invalidated_entries_1 && ldq_check_invalidated_entries_2 && stq_check_invalidated_entries_1 && stq_check_invalidated_entries_2) == 1'b1;

		during[t, t+O]: (full_empty_logic_1 && full_empty_logic_2 && empty_logic_1 && empty_logic_2 && full_logic_1 && full_logic_2) == 1'b1;

		during[t, t+O]: (consistent_valid_flags_1 && consistent_valid_flags_2) == 1'b1;
    
		during[t, t+O]: (no_speculative_head_1 && no_speculative_head_2) == 1'b1;

		during[t, t+O]: (no_speculative_commit_1 && no_speculative_commit_2) == 1'b1;
		
	        during[t, t+O]: (lcam_ldq_idx_valid_1 && lcam_ldq_idx_valid_2 && lcam_stq_idx_valid_1 && lcam_stq_idx_valid_2) == 1'b1;
	        
	        during[t, t+O]: (ldq_consistent_rob_idx_1 && ldq_consistent_rob_idx_2 && stq_consistent_rob_idx_1 && stq_consistent_rob_idx_2) == 1'b1;
	         
	        during[t, t+O]: (consistent_stq_committed_1 && consistent_stq_committed_2) == 1'b1;
    
		during[t, t+O]: (committed_stores_not_speculative_1 && committed_stores_not_speculative_2) == 1'b1;
		
		during[t, t+O]: (!speculative_store_rpq_1 && !speculative_store_rpq_2) == 1'b1;
    
   		during[t, t+O]: (!speculative_store_s1_s2_1 && !speculative_store_s1_s2_2) == 1'b1;

		during[t, t+O]: (fpiu_BranchKillableQueue_1_not_committed_1 && fpiu_BranchKillableQueue_1_not_committed_2) == 1'b1;
		
		during[t, t+O]: (fdivsqrt_valid_consistency_1 && fdivsqrt_valid_consistency_2) == 1'b1;
		
		during[t, t+O]: (div_state_1 && div_state_2) == 1'b1;
		
		during[t, t+O]: (ldq_entries_not_using_stq_1 && ldq_entries_not_using_stq_2 && stq_entries_not_using_ldq_1 && stq_entries_not_using_ldq_2) == 1'b1;
		
		during[t, t+O]: (ROB_uops_equal_STQ_1 && ROB_uops_equal_STQ_2 && ROB_uops_equal_LDQ_1 && ROB_uops_equal_LDQ_2 && STQ_uops_equals_ROB_1 && STQ_uops_equals_ROB_2 && LDQ_uops_equals_ROB_1 && LDQ_uops_equals_ROB_2) == 1'b1;
		
		during[t, t+O]: (prevent_overwriting_valid_entries_1 && prevent_overwriting_valid_entries_2) == 1'b1;
		
		//during[t, t+O]: com_mispred_kills_root == 1'b1;

		//during[t, t+O]: enqueue_uncom_br_tags == 1'b1;

		//during[t, t+O]: root_br_mispred == 1'b1;

		//during[t, t+O]: (bkq_jmp_rob_consistency_1 && bkq_jmp_rob_consistency_2 && bkq_fp_rob_consistency_1 && bkq_fp_rob_consistency_2 && bkq_fp_1_rob_consistency_1 && bkq_fp_1_rob_consistency_2) == 1'b1;
    
    		during[t, t+O]: (buffers_equal_ROB_1 && buffers_equal_ROB_2) == 1'b1;
    		
    		during[t, t+O]: (unique_stq_idx_1 && unique_stq_idx_2) == 1'b1;
    		
	        during[t, t+O]: (stdf_clr_bsy_uses_stq_1 && stdf_clr_bsy_uses_stq_2) == 1'b1;
    		
		//during[t, t+O]: addr_index_in_bounds == 1'b1;

		during[t, t+O]: br_tag_protection == 1'b1;
		
	    	during[t, t+O]: consistent_uncommittable_masks == 1'b1;
	    	
	    	during[t, t+O]: (BranchKillableQueue_empty_1 && BranchKillableQueue_empty_2) == 1'b1;
	    	
	    	during[t, t+O]: (BranchKillableQueue_pointers_valid_1 && BranchKillableQueue_pointers_valid_2) == 1'b1;
	    	
		during[t, t+O]: (valid_issue_slots_1 && valid_mispred_idx_1 && valid_iregister_read_1 && valid_issue_slots_2 && valid_mispred_idx_2 && valid_iregister_read_2) == 1'b1;
		
	    	during[t, t+O]: (fdivsqrt_consistency_1 && fdivsqrt_consistency_2) == 1'b1;
	    	
	    	//use chisel assertion from fdiv.scala line 134
	    	during[t, t+O]: (soc1/core/fp_pipeline/fpiu_unit/fdivsqrt/_T_135 && soc2/core/fp_pipeline/fpiu_unit/fdivsqrt/_T_135) == 1'b1;

		//excluded attacks

		during[t, t+O]: soc1/core/fp_pipeline/fpiu_unit/fpu_io_resp_valid == soc2/core/fp_pipeline/fpiu_unit/fpu_io_resp_valid;

		during[t, t+O]: soc1/core/ll_wbarb/io_in_0_valid == soc2/core/ll_wbarb/io_in_0_valid;

		during[t, t+O]: soc1/core/fp_pipeline/fpiu_unit/Arbiter/io_in_0_valid == soc2/core/fp_pipeline/fpiu_unit/Arbiter/io_in_0_valid;

		during[t, t+O]: soc1/core/fp_pipeline/ll_wbarb/io_in_0_valid == soc2/core/fp_pipeline/ll_wbarb/io_in_0_valid;

		during[t, t+O]: soc1/core/csr_exe_unit/alu_io_resp_valid == soc2/core/csr_exe_unit/alu_io_resp_valid;

		during[t, t+O]: cache_resp_equal == 1'b1;

		during[t, t+O]: uncache_resp_equal == 1'b1;

		during[t, t+O]: wb_forward_valid_equal == 1'b1;

		during[t, t+O]: dmem_resp_fired_equal == 1'b1;

		during[t, t+O]: mshrs_resp_arb_valid_equal == 1'b1;

		during[t, t+O]: dis_hazards_equal == 1'b1;
		
		//port contention between stores and fp_stores with static priority
		during[t, t+O]: soc1/lsu/io_core_fp_stdata_ready == soc2/lsu/io_core_fp_stdata_ready;
		
		//port contention in jmp_unit between alu and imul (static priority)
		during[t, t+O]: soc1/core/jmp_unit/alu_io_resp_valid == soc2/core/jmp_unit/alu_io_resp_valid;
		
		//port contention on LSU port to memory (static priority)
		during[t, t+O]: soc1/lsu/fired_load_incoming_0 == soc2/lsu/fired_load_incoming_0 &&
				soc1/lsu/fired_stad_incoming_0 == soc2/lsu/fired_stad_incoming_0 &&
				soc1/lsu/fired_sta_incoming_0 == soc2/lsu/fired_sta_incoming_0 &&
				soc1/lsu/fired_std_incoming_0 == soc2/lsu/fired_std_incoming_0 &&
				soc1/lsu/fired_stdf_incoming == soc2/lsu/fired_stdf_incoming &&
				soc1/lsu/fired_sfence_0 == soc2/lsu/fired_sfence_0 &&
				soc1/lsu/fired_release_0 == soc2/lsu/fired_release_0 &&
				soc1/lsu/fired_load_retry_0 == soc2/lsu/fired_load_retry_0 &&
				soc1/lsu/fired_sta_retry_0 == soc2/lsu/fired_sta_retry_0 &&
				soc1/lsu/will_fire_store_commit_0 == soc2/lsu/will_fire_store_commit_0 &&
				soc1/lsu/fired_load_wakeup_0 == soc2/lsu/fired_load_wakeup_0 &&
				soc1/lsu/will_fire_hella_incoming_0 == soc2/lsu/will_fire_hella_incoming_0 &&
				soc1/lsu/will_fire_hella_wakeup_0 == soc2/lsu/will_fire_hella_wakeup_0
				;
				
		//fixed priority arbitration for output of BranchKillableQueues because of "flow queue" behaviour (if queue empty, input can directly go to output)
		during[t, t+O]: soc1/core/jmp_unit/BranchKillableQueue/io_empty == soc2/core/jmp_unit/BranchKillableQueue/io_empty &&
				soc1/core/fp_pipeline/fpiu_unit/BranchKillableQueue/io_empty == soc2/core/fp_pipeline/fpiu_unit/BranchKillableQueue/io_empty &&
				soc1/core/fp_pipeline/fpiu_unit/BranchKillableQueue_1/io_empty == soc2/core/fp_pipeline/fpiu_unit/BranchKillableQueue_1/io_empty;
		
		//fixed "priority" in LSU for handling dmem response
		during[t, t+O]: soc1/lsu/io_dmem_resp_0_bits_uop_uses_ldq == soc2/lsu/io_dmem_resp_0_bits_uop_uses_ldq && soc1/lsu/io_dmem_resp_0_bits_uop_uses_stq == soc2/lsu/io_dmem_resp_0_bits_uop_uses_stq;
		
		
		//fixed priority arbitration for replay arbiter in mshrs
		during[t, t+O]: soc1/dcache/mshrs/replay_arb/io_in_0_valid == soc2/dcache/mshrs/replay_arb/io_in_0_valid;
		during[t, t+O]: soc1/dcache/mshrs/replay_arb/io_in_1_valid == soc2/dcache/mshrs/replay_arb/io_in_1_valid;
		
		//fixed priority arbitration for dataRead arbiter in dcache
		during[t, t+O]: soc1/dcache/dataReadArb/io_in_0_valid == soc2/dcache/dataReadArb/io_in_0_valid;
		during[t, t+O]: soc1/dcache/dataReadArb/io_in_1_valid == soc2/dcache/dataReadArb/io_in_1_valid;
		during[t, t+O]: soc1/dcache/dataReadArb/io_in_2_valid == soc2/dcache/dataReadArb/io_in_2_valid;
		
		//fixed priority arbitration for metaRead arbiter in dcache
		during[t, t+O]: soc1/dcache/metaReadArb/io_in_0_valid == soc2/dcache/metaReadArb/io_in_0_valid;
		during[t, t+O]: soc1/dcache/metaReadArb/io_in_1_valid == soc2/dcache/metaReadArb/io_in_1_valid;
		during[t, t+O]: soc1/dcache/metaReadArb/io_in_2_valid == soc2/dcache/metaReadArb/io_in_2_valid;
		during[t, t+O]: soc1/dcache/metaReadArb/io_in_3_valid == soc2/dcache/metaReadArb/io_in_3_valid;
		during[t, t+O]: soc1/dcache/metaReadArb/io_in_4_valid == soc2/dcache/metaReadArb/io_in_4_valid;
		
		//if mispredict rob_idx is committable, mispredict signals have to be equal, else they can differ
		during[t, t+O]: uncom_branch_resolution == 1'b1;


		during[t, t+O]: (commit_index < 2);
	prove:

		//at t+O: lAlert == 1'b0 /*&& lAlert_earlyAlarm == 1'b0*/;
		at t+O: (!(mispred_happened_1 && mispred_happened_2) && (!root_id_killed && !root_id_already_killed) && (ROB_commit_array_1[commit_index] != ROB_commit_array_2[commit_index])) == 1'b0;

end property;